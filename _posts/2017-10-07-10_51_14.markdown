---
layout:     post
title:      "A C++ implement for KD-tree"
subtitle:   "Distance is defined as the correlation"
date:       2017-10-07
author:     "Ziping"
header-img: "img/c.jpg"
catalog: true
tags:
    - c/c++
    - kd-tree
---

# A C++ implement for KD-tree

KD-tree is a very efficient way to search similar samples. In my porject on stock market, I want to measure the similarity between a new strategy and all the strategies in my strategy library. If the distance is larger enough I would accept the new one and add it into the library. If you compare all the samples, it will cost a lot of time. KD tree is a solution. 

The following is the header file and some implement for KD-tree in C++.

The distance here is the correlation of two series.

```c
/*
KD tree for finding k nearest with distance measured by correlation
ziping 
20170908
*/

#define MAX_LEN 2328
#define MAX_STR 512
#include <vector>
#include <string>
#include <queue>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <stack>
#include <dirent.h>

using namespace std;

typedef struct KDtree{
	double data[MAX_LEN]; // data
	int dim; // current dimension 
	char* alpha_id;
	struct KDtree *left; // left child
	struct KDtree *right; // right child
}kdtree_node;

typedef class result{
public:
	char* alpha_id;
	double correlation;

	result(char* alpha_id, double correlation): alpha_id(alpha_id), correlation(correlation){};

	bool operator<(const result& t){
		return this->correlation < t.correlation;
	}
}k_result;

// Find the medium in a series
class Solution {
public:
	Solution(){
		count = 0;
	}
    void Insert(double data)
    {
	    count++;
	    if(count%2==0)
	    {
	        big_heap.push(data);
	        double value = big_heap.top();
	        small_heap.push(value);
	        big_heap.pop();
	    }
	    else
	    {
	        small_heap.push(data);
	        double value = small_heap.top();
	        big_heap.push(value);
	        small_heap.pop();
	    }
    }

    double GetMedian()
    { 
    	//cout << count << endl;
    	//cout << big_heap.top() << ", " << small_heap.top() << endl;
        if(count%2==0)
        {
            return double((big_heap.top() + small_heap.top()))/2;
        }
        else
            return big_heap.top();
    }
private:
    int count;
    priority_queue<double, vector<double>, less<double> > big_heap;
    priority_queue<double, vector<double>, greater<double> > small_heap;
};

// compute correlation
double correlation(double *a, double *b, int dim){
	double d = 0.0;
	for(int i = 0; i < dim; i++){
		d += a[i] * b[i];
	}
	return d;
}

// compute Euclid distance
double distance(double *a, double *b, int dim){
	double d = 0.0;
	for (int i = 0; i < dim; i++){
		d += (a[i] - b[i]) * (a[i] - b[i]);
	}
	return d;
}

double distance_except_dim(double *a, double *b, int except_dim){
	double d = (a[except_dim] - b[except_dim]) * (a[except_dim] - b[except_dim]);
	return d;
}

/*
void saveTree(kdtree_node * &tree_node, char* targetName){
	// To be implemented	
}
*/

/*/ 递归构建kd树，通过节点所在的层数控制选择的维度
int kdtree_insert(kdtree_node * &tree_node, double *data, string alpha_id, int layer, int dim){
	// 空树
	if (NULL == tree_node){
		// 申请空间
		//tree_node = (kdtree_node *)malloc(sizeof(kdtree_node));
		tree_node = new kdtree_node;
		if (NULL == tree_node) return 1;

		//插入元素
		for (int i = 0; i < dim; i ++){
			(tree_node->data)[i] = data[i];
		}
		tree_node->dim = layer % (dim);
		tree_node->alpha_id = alpha_id;
		tree_node->left = NULL;
		tree_node->right = NULL;

		return 0;
	}
	
	// 插入左子树
	if (data[tree_node->dim] <= (tree_node->data)[tree_node->dim]){
		return kdtree_insert(tree_node->left, data, alpha_id, ++layer, dim);
	}
	
	// 插入右子树
	return kdtree_insert(tree_node->right, data, alpha_id, ++layer, dim);
}*/

// Build a new tree
void kdtree_build(kdtree_node * &tree_node, double **data, string* alpha_id, int layer, int num, int dim, bool* subGroup, bool ifLog = false){	
	// 空树
	// 申请空间
	if(ifLog)
		cout << "Build: " << layer << "th Layer" << endl;
	//tree_node = (kdtree_node *)malloc(sizeof(kdtree_node));
	tree_node = new kdtree_node;
	if (NULL == tree_node) return;

	//插入元素
	//首先确定需要插入哪个元素
	Solution find_median = Solution();
	int t_dim = layer % (dim);
	for(int i = 0; i < num; i++){
		if(subGroup[i] == true){
			//cout << data[i][t_dim] <<",";
			find_median.Insert(data[i][t_dim]);
		}
	}
	double median = find_median.GetMedian();
	double mini = 1000;
	int mIndex = 0;
	int m;
	for(m = 0; m < num; m++){
		if((subGroup[m] == true) && (fabs(median - data[m][t_dim]) < mini)){
			mini = fabs(median - data[m][t_dim]);
			mIndex = m;
		}
	}
	if(ifLog)
		cout << "\t" << "Select: " << mIndex << "th alpha: " << "\n" << alpha_id[mIndex] << endl;
	//cout << median << endl;
	for (int i = 0; i < dim; i++){
		(tree_node->data)[i] = data[mIndex][i];
	}
	tree_node->dim = layer % (dim);

	tree_node->alpha_id = new char[MAX_STR];
	int len = alpha_id[mIndex].length();
	alpha_id[mIndex].copy(tree_node->alpha_id, len, 0);

	tree_node->left = NULL;
	tree_node->right = NULL;
	bool* leftSubGroup = new bool[num];
	bool left = false;
	bool* rightSubGroup = new bool[num];
	bool right = false;
	for(int i = 0; i < num; i++){
		if(subGroup[i] == false){
			leftSubGroup[i] = false;
			rightSubGroup[i] = false;
			continue;
		}
		if(data[i][t_dim] > data[mIndex][t_dim]){
			leftSubGroup[i] = false;
			rightSubGroup[i] = true;
			right = true;
		}
		else if(data[i][t_dim] < data[mIndex][t_dim]){
			rightSubGroup[i] = false;
			leftSubGroup[i] = true;
			left = true;
		}
		else{
			leftSubGroup[i] = false;
			rightSubGroup[i] = false;
		}
	}
	/* The distribution!
	cout << left << ", " << right << endl;
	for(int i = 0; i < num; i++)
		cout << leftSubGroup[i] << ",";
	cout << endl;
	for(int i = 0; i < num; i++)
		cout << rightSubGroup[i] << ",";
	cout << endl;
	*/
	// 插入左子树
	if (left){
		kdtree_build(tree_node->left, data, alpha_id, layer + 1, num, dim, leftSubGroup);
	}
	// 插入右子树
	if(right){
		kdtree_build(tree_node->right, data, alpha_id, layer + 1, num, dim, rightSubGroup);
	}
}

// search the alpha with a correlation larger than a threshold
void search_nearestK(kdtree_node *tree, double *data_search, int dim, vector<k_result>* result, double thred, bool ifLog = false){
	//对距离的阈值设置
	double* theta = new double;
	*theta = acos(thred);
	double* thred_dis = new double;
	*thred_dis = 4 * sin(*theta / 2) * sin(*theta / 2);
	stack<kdtree_node *> st;
	if(ifLog)
		cout << *thred_dis << endl;
	kdtree_node *p = tree;
	
	while (p->left != NULL || p->right != NULL){
		st.push(p);// 将p压栈
		if (data_search[p->dim] <= (p->data)[p->dim]){// 选择左子树
			// 判断左子树是否为空
			
			if (p->left == NULL) break;
			p = p->left;
		}else{ // 选择右子树
			
			if (p->right == NULL) break;
			p = p->right;
		}
	}
	st.push(p);
	double d = 0;
	while (st.size() > 0){
		kdtree_node *q = st.top();// 找到栈顶元素
		st.pop(); // 出栈
		
		// 判断与父节点之间的距离
		if(ifLog)
			cout << "Search: " << q->alpha_id << endl;

		d = distance(data_search, q->data, dim);
		if(ifLog)
			cout << "\t" << "The distance is: " << d << endl;
		if (d <= *thred_dis){
			double corr = correlation(data_search, q->data, dim);
			if(ifLog)
				cout << "\t" << "The Correlation is: " << corr << endl;
			result->push_back(k_result(q->alpha_id, corr));
		}
		if(ifLog)
			cout << endl;

		// 判断与分隔面是否相交
		double d_line = distance_except_dim(data_search, q->data, q->dim); // 到平面之间的距离
		if (d_line < *thred_dis){ // 相交
			// 如果本来在右子树，现在查找左子树
			// 如果本来在左子树，现在查找右子树
			if (data_search[q->dim] > (q->data)[q->dim]){
				// 选择左子树
				if (q->left != NULL) q = q->left;
				else q = NULL;
			}else{
				// 选择右子树
				if (q->right != NULL) q = q->right;
				else q = NULL;
			}
			if (q != NULL){
				while (q->left != NULL || q->right != NULL){
					st.push(q);
					if (data_search[q->dim] <= (q->data)[q->dim]){
						if (q->left == NULL) break;
						q = q->left;
					}else{
						if (q->right == NULL) break;
						q = q->right;
					}
				}
				if (q->left == NULL && q->right == NULL) st.push(q);
			}
		}
	}
}

// print trees
void kdtree_print(kdtree_node *tree, int dim){
	if (tree != NULL){
		fprintf(stderr, "dim:%d ", tree->dim);
		//cout << tree->alpha_id << endl;
		for (int i = 0; i < dim; i++){
			fprintf(stderr, "%lf\t", (tree->data)[i]);
		}
		fprintf(stderr, "\n");
		kdtree_print(tree->left, dim);
		kdtree_print(tree->right, dim);
	}
}

void kdtree_print_in(kdtree_node *tree, int dim){
	if (tree != NULL){
		kdtree_print_in(tree->left, dim);
		fprintf(stderr, "dim:%d\n", tree->dim);
		cout << tree->alpha_id << endl;
		for (int i = 0; i < dim; i++){
			fprintf(stderr, "%lf\t", (tree->data)[i]);
		}
		fprintf(stderr, "\n");
		kdtree_print_in(tree->right, dim);
	}
}

```

